(window.webpackJsonp=window.webpackJsonp||[]).push([[198],{619:function(t,e,n){"use strict";n.r(e);var v=n(30),_=Object(v.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h3",{attrs:{id:"python2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#python2"}},[t._v("#")]),t._v(" python2")]),t._v(" "),n("ul",[n("li",[t._v("python2默认编码ascIII")]),t._v(" "),n("li",[t._v("字符串编码默认ASCII编码")]),t._v(" "),n("li",[t._v("py2有Unicode类型，encode后才是字符型")]),t._v(" "),n("li",[t._v("所以要表示中文，要在开头声明，以此种编码解码到内存，而且内存上的也是此种编码，这样的话在Windows上就可能是乱码的了  eg： #! -"),n("em",[t._v("- coding: utf-8 -")]),t._v("-    or    #!encoding:utf-8\n")]),n("li",[t._v("手动转码\n"),n("ul")]),t._v(" "),n("li",[t._v("UTF-8 --\x3e decode 解码 --\x3e Unicode")]),t._v(" "),n("li",[t._v("Unicode --\x3e encode 编码 --\x3e GBK / UTF-8 ..　bytes")])]),t._v(" "),n("h3",{attrs:{id:"python3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#python3"}},[t._v("#")]),t._v(" **python3 **")]),t._v(" "),n("ul",[n("li",[t._v("python3默认编码utf-8")]),t._v(" "),n("li",[t._v("字符串编码默认Unicode")]),t._v(" "),n("li",[t._v("py3没有Unicode类型，只有str类型")]),t._v(" "),n("li",[t._v("解释器找到代码文件，把代码字符串按文件头定义的编码加载到内存，自动转成unicode")]),t._v(" "),n("li",[t._v("把代码字符串按照语法规则进行解释，")]),t._v(" "),n("li",[t._v("所有的变量字符都会以unicode编码声明")]),t._v(" "),n("li",[t._v("把unicode编码后，字符串就变成了bytes格式，必须得是unicode编码，才显示字符")]),t._v(" "),n("li",[t._v("内存为Unicode，但存储到硬盘，却要转换成utf-8，是为了存储传输")])]),t._v(" "),n("h3",{attrs:{id:"py3只有两种数据类型-str-和bytes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#py3只有两种数据类型-str-和bytes"}},[t._v("#")]),t._v(" py3只有两种数据类型 str,和bytes**")]),t._v(" "),n("p",[t._v("为什么在py3里，把unicode编码后，字符串就变成了bytes格式？ 你直接给我直接打印成gbk的字符展示不好么？我想其实py3的设计真是煞费苦心，就是想通过这样的方式明确的告诉你，想在py3里看字符，必须得是unicode编码，其它编码一律按bytes格式展示。")]),t._v(" "),n("p",[n("strong",[t._v("注意：")])]),t._v(" "),n("ul",[n("li",[t._v("所有系统都支持Unicode")]),t._v(" "),n("li",[t._v('chr(97)  >>>"a"    #转换ASCII码')])])])}),[],!1,null,null,null);e.default=_.exports}}]);