(window.webpackJsonp=window.webpackJsonp||[]).push([[239],{660:function(_,s,n){"use strict";n.r(s);var e=n(30),t=Object(e.a)({},(function(){var _=this,s=_.$createElement,n=_._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[n("p",[_._v("类成员")]),_._v(" "),n("p",[_._v("字段")]),_._v(" "),n("li",[_._v("普通字段\n"),n("ul",[_._v("\n- 属于对象，存储在对象空间　　\n- 使用self.字段名操作　　\n"),n("ul",[n("li",[_._v("属于类，存储在类空间，如果对象有重名字段，静态字段会被覆盖")]),_._v(" "),n("li",[_._v("使用类名.字段名访问")]),_._v(" "),n("li",[_._v("使用对象名.字段名访问")])]),_._v(" "),n("p",[_._v("方法")]),_._v(" "),n("li",[_._v("普通方法\n"),n("ul",[_._v("\n- 由对象调用，至少一个self参数，　　\n- 执行时自动将该方法的对象赋值给self　　\n"),n("ul",[n("li",[n("p",[_._v("定义时加上@classmethod装饰器")])]),_._v(" "),n("li",[n("p",[_._v("由类调用，至少一个cls参数")])]),_._v(" "),n("li",[n("p",[_._v("执行时自动将该方法的类赋值给cls")])]),_._v(" "),n("li",[n("p",[_._v("定义时加上@staticmethod装饰器")])]),_._v(" "),n("li",[n("p",[_._v("由类调用，无默认参数")])])]),_._v(" "),n("p",[_._v("属性")]),_._v(" "),n("p",[_._v("普通属性普通方法的变种，定义普通方法时加上@property装饰器相关方法")]),_._v(" "),n("p",[_._v("isinstance(object,classinfo)和issubclass(class,classinfo)")]),_._v(" "),n("p",[_._v("isinstance用于判断object是否是classinfo、或classinfo直接、间接的子类的实例（instance），返回值为bool类型classinfo可以是一个包含多个类的元组，只要object按照上面的规则符合其中一个就会返回Trueissubclass用于判断class是否是classinfo、或classinfo直接、间接的子类，返回值为布尔类型")]),_._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[_._v("class A:\npass\n\nclass B(A):\npass\n\nclass C(B):\npass\n\nclass D:\npass\n\nx = C()\n# x是C的直接的实例\nprint(isinstance(x, C))\n# x是B的间接的实例\nprint(isinstance(x, B))\n# x不是D的实例\nprint(isinstance(x, D))\n\n# classinfo可以是一个元组\nprint(isinstance(x, (A, D)))\n\n# C是B的直接子类\nprint(issubclass(C, B))\n# C是A的间接子类\nprint(issubclass(C, A))\n# C不是D的子类\nprint(issubclass(C, D))\n")])])]),n("p",[_._v("内置方法")]),_._v(" "),n("p",[n("strong",[_._v("new__当类开始实例化出对象时执行该方法正常的实例化由object类的__new__执行该方法，并返回一个对象通常使用该方法在实例化出对象时额外进行一些操作，然后返回object类的__new")]),_._v("  class A:      def "),n("strong",[_._v("init")]),_._v("(self):          print('in init function')          self.x = 1\t      def "),n("strong",[_._v("new")]),_._v("(cls, *args, **kwargs):          print('in new function')          return object."),n("strong",[_._v("new")]),_._v("(A, *args, **kwargs)单例模式：一个类仅有一个对象。class Singleton:    def "),n("strong",[_._v("new")]),_._v("(cls, *args, **kw):        if not hasattr(cls, '_instance'):            cls._instance = object."),n("strong",[_._v("new")]),_._v("(cls, *args, **kw)        return cls._instance")]),_._v(" "),n("p",[_._v("one = Singleton()two = Singleton()three = Singleton()print(one,two,three)__init__执行__new__之后执行该方法__str__和__repr__当打印对象时，会打印str的返回值当str方法不存在，repr会代替str__del__当对象被del的时候执行方法item系列 getitem用在从对象取值的时候使用方法内的返回值，setitem用于给对象的属性赋值操作，delitem用于删除对象的属性__getitem____setitem____delitem__class Foo:    def "),n("strong",[_._v("init")]),_._v("(self):        self.name = 'jack'        self.age = 24            def "),n("strong",[_._v("getitem")]),_._v("(self, item):        return self."),n("strong",[_._v("dict")]),_._v("[item]")]),_._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[_._v("def __setitem__(self, key, value):        self.__dict__[key] = value\n\ndef __delitem__(self, key):        del self.__dict__[key]f = Foo()print(f['name'])f['name'] = 'bob'del f['name']__call__定义在将对象当做函数调用时执行的方法__len__定义在对对象使用len函数时执行的方法__hash__定义在对对象使用hash函数时执行的方法__eq__定义在对两个对象使用==运算符时执行的方法__add__定义在对象相加时执行的方法__mul__定义在对象相乘时执行的方法__setattr____getattr____delattr__flask源码、请求上下文管理的类似本地线程功能比本地线程更厉害，因为可以保证协程级别的数据不混淆__enter__上下文协议入口，需要返回值__exit__上下文协议出口\n")])])]),n("p",[_._v("属于对象，存储在对象空间使用self.字段名操作")])])])])])])}),[],!1,null,null,null);s.default=t.exports}}]);