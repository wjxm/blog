(window.webpackJsonp=window.webpackJsonp||[]).push([[230],{651:function(e,t,s){"use strict";s.r(t);var n=s(30),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("创建socket内含参数")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" def __init__(self, family=AF_INET, type=SOCK_STREAM, proto=0, fileno=None):\n        # For user code address family and type values are IntEnum members, but\n        # for the underlying _socket.socket they're just integers. The\n        # constructor of _socket.socket converts the given argument to an\n        # integer automatically.\n        _socket.socket.__init__(self, family, type, proto, fileno)\n        self._io_refs = 0\n        self._closed = False\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("**family 代表IP类型  AF_INET 表示IPV4,AF_INER6表示IPv6,AF_UNIX表示在Unix下**\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("**type 代表协议，SOCK_STREAM代表tcp协议，COCK_DEGRAM代表udp协议**\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('import socket        \n\nsk = socket.socket()                    创建socket对象\naddress = ("169.254.77.227",8000)      加载地址，绑定端口\nsk.bind(address)                         绑定ID\nsk.listen(2)                              确定可同时等待的人数\n\nprint("waiting....")        \nwhile 1:                                在一个连接断开得的时候可以连接另一个连接\n    conn, addr = sk.accept()             接收客户端的地址信息\n    print(addr)\n    while True:                        在一个连接没有断开请求时，一直通话\n        try:                           防止这边堵塞时，客户端停止服务\n            data = conn.recv(1024)                  #Linux下不会报错 返回一个空值\n        except Exception as e:\n            break\n        print(".......", str(data, "utf8"))\n        if not data: break                        如果接到的要求，就退出\n        innp = input(">>>")\n        conn.send(bytes(innp, "utf-8"))\n\nsk.close()\n')])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('import socket\nsk = socket.socket()\naddress = ("169.254.77.227",8000)　　　　　　　　#设置服务端IP\nsk.connect(address)　　　　　　　　　　　　　　　　#连接服务端\nwhile True:\n    innp = input(">>>")　　　　　　　　　　　　\n    if innp == "exit":　　　　　　　　　　　　　　#如果输入不是exit就不退出\n        break\n    sk.send(bytes(innp, "utf-8"))　　　　　　　　#发送应该以bytes格式\n\n    data = sk.recv(1024)\n    print(str(data, "utf8"))\nsk.close()\n')])])]),s("p",[e._v("通过subpross模块来达到远程执行命令")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('import socket\nimport subprocess\n\nsk = socket.socket()\naddress = ("169.254.77.227",8000)\nsk.bind(address)\nsk.listen(2)\n\nprint("waiting....")\nwhile 1:\n    conn, addr = sk.accept()\n    print(addr)\n    while True:\n        try:\n            data = conn.recv(1024)       #Linux下不会报错\n        except Exception as e:\n            break\n        print(".......", str(data, "utf8"))\n        if not data: break\n　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　#popen默认data应该为str数据\n        obj = subprocess.Popen(str(data,"gbk"),shell=True,stdout=subprocess.PIPE)　　　　　　#将独立进程的subprocess通过stdout管道转到主进程\n        　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　#用命令的方式执行data　　　　 cmd_result = obj.stdout.read()　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　读取通道内容，为bytes类型，以gbk(windows)编码\n        result_len = bytes(str(len(cmd_result)),"utf8")\n        conn.sendall(result_len)　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　#粘包现象　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　#当有两个send连续发送时，第一个发送的数据很小，系统会在很短的时间内等一下，和下一个发送一起发送\n        　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 有时出现有时不出现　　　　　conn.recv(1024)　　　　　　　　　　　　#通过多加一个recv打断粘包（客户端接收时相应的加一个send）　　　　　conn.sendall(cmd_result)　　　　　　　　　　　　　　　　　　　　　　　　　　　　\n')])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" \n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("sk.close()\n")])])]),s("p",[e._v("远程执行命令情况下的客户端")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('import socket\nsk = socket.socket()\naddress = ("169.254.77.227",8000)\nsk.connect(address)\nwhile True:\n    innp = input(">>>")\n    if innp == "exit":\n        break\n    sk.send(bytes(innp, "utf-8"))\n    result_len = int(str(sk.recv(1024),"utf8"))\n    # data = sk.recv(1024)\n\n    print(result_len)\n    data = bytes()\n    while len(data)!=result_len:　　　　　　　　　　命令行数据发送有大小限制，通过事先发送命令行的大小，然后通过数据的大小建立循环带到不刚好读取完成\n        recv = sk.recv(1024)\n        data+=recv\n\n    # while not data:\n    #     data = sk.\n    print(str(data, "gbk"))　　　　　　　　　　　　　　#转换会生成时的编码\n')])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("读取通道内容，\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("sk.close()\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('import socketsk = socket.socket()address = ("169.254.77.227",8000)sk.bind(address)sk.listen(2)print("waiting....")while 1:    conn, addr = sk.accept()    print(addr)    while True:        try:            data = conn.recv(1024)       #Linux下不会报错except Exception as e:            breakprint(".......", str(data, "utf8"))        if not data: breakinnp = input(">>>")        conn.send(bytes(innp, "utf-8"))sk.close()\n')])])])])}),[],!1,null,null,null);t.default=a.exports}}]);