(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{489:function(t,a,s){"use strict";s.r(a);var _=s(30),v=Object(_.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"什么是数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是数组"}},[t._v("#")]),t._v(" 什么是数组")]),t._v(" "),s("blockquote",[s("p",[t._v("数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。")])]),t._v(" "),s("ul",[s("li",[s("h4",{attrs:{id:"线性表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线性表"}},[t._v("#")]),t._v(" 线性表")]),t._v(" "),s("p",[t._v("线性表就是数据排成像一条线一样的结构。\n常见的线性表结构：数组，链表、队列、栈等。")]),t._v(" "),s("img",{staticStyle:{width:"400px",margin:"0","text-align":"left"},attrs:{src:"https://leiyiming.oss-cn-shenzhen.aliyuncs.com/img/b6b71ec46935130dff5c4b62cf273477.jpg"}})])]),t._v(" "),s("ul",[s("li",[s("h4",{attrs:{id:"非线性表-："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#非线性表-："}},[t._v("#")]),t._v(" 非线性表  ：")]),t._v(" "),s("p",[t._v("数据之间并不是简单的前后关系,包括二叉树、堆、图等\n"),s("img",{staticStyle:{width:"400px",margin:"0","text-align":"left"},attrs:{src:"http://img.leiyiming.top/blog/6ebf42641b5f98f912d36f6bf86f6569.jpg",alt:"img"}})])]),t._v(" "),s("li",[s("p",[t._v("连续的内存空间和相同类型的数据")]),t._v(" "),s("ul",[s("li",[t._v("优点：两限制使得具有随机访问的特性")]),t._v(" "),s("li",[t._v("缺点：删除，插入数据效率低")])])])]),t._v(" "),s("h3",{attrs:{id:"数组怎么根据下标随机访问的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组怎么根据下标随机访问的？"}},[t._v("#")]),t._v(" 数组怎么根据下标随机访问的？")]),t._v(" "),s("blockquote",[s("p",[t._v("通过寻址公式，计算出该元素存储的内存地址：")]),t._v(" "),s("p",[t._v("32位机器上一个地址占4个字节,  (一个地址占32 位,32/8 = 4 个字节)")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("a[i]_address = base_address + i * data_type_size\n#比如\n列表变量中存储,列表的首地址,比如列表a 首地址为32,  那么a[i] 地址就是32+i*4 \n")])])]),s("h3",{attrs:{id:"python中列表-与类c语言的数组的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#python中列表-与类c语言的数组的区别"}},[t._v("#")]),t._v(" python中列表,与类C语言的数组的区别")]),t._v(" "),s("ul",[s("li",[t._v("数组元素类型相同(python可以不相同)")]),t._v(" "),s("li",[t._v("数组长度固定,(python不固定)")])]),t._v(" "),s("h4",{attrs:{id:"python实现列表元素类型不相同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#python实现列表元素类型不相同"}},[t._v("#")]),t._v(" python实现列表元素类型不相同")]),t._v(" "),s("p",[s("strong",[t._v("python列表中实际是存的地址")])]),t._v(" "),s("p",[t._v("python: 在内存中有开辟一些固定内存来存放特定值,假如数值 1 ,2,3 固定地址分布为,100,200,300,")]),t._v(" "),s("p",[t._v("那么在赋值时,a= 1  就是将a指向100 这块内存, b=2 就是将b指向200 这块内存")]),t._v(" "),s("p",[t._v("同时")]),t._v(" "),s("p",[t._v("假如列表 a 内存地址为400, 在求a[2]时是有两个步骤,")]),t._v(" "),s("ol",[s("li",[t._v("求出a[2]的内存地址   400 + 4*2 = 408  ,    408 中也是存储元素的内存地址")]),t._v(" "),s("li",[t._v("获取408中的内存地址后,假如为2000,  再去拿2000 的值就是a[2]")])]),t._v(" "),s("h4",{attrs:{id:"python实现列表长度不固定"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#python实现列表长度不固定"}},[t._v("#")]),t._v(" python实现列表长度不固定")]),t._v(" "),s("ul",[s("li",[t._v("当列表满了,还要append时,python内部将开辟一个更大(可能多n个元素)的列表,把元素列表元素拷贝过来,")])]),t._v(" "),s("h3",{attrs:{id:"为什么数组要从-0-开始编号？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么数组要从-0-开始编号？"}},[t._v("#")]),t._v(" 为什么数组要从 0 开始编号？")]),t._v(" "),s("blockquote",[s("p",[t._v("由于数组是通过寻址公式，计算出该元素存储的内存地址：")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("a[i]_address = base_address + i * data_type_size\n\n# 如果数组是从 1 开始计数，那么就会变成：\na[i]_address = base_address + （i-1）* data_type_size\n")])])]),s("ul",[s("li",[t._v("对于CPU来说，多了一次减法的指令。")]),t._v(" "),s("li",[t._v("当然，还有一定的历史原因,后期的编程语言很多是遗传c")])]),t._v(" "),s("h3",{attrs:{id:"为何数组插入和删除低效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为何数组插入和删除低效"}},[t._v("#")]),t._v(" 为何数组插入和删除低效")]),t._v(" "),s("h6",{attrs:{id:"插入："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#插入："}},[t._v("#")]),t._v(" "),s("strong",[t._v("插入：")])]),t._v(" "),s("p",[t._v("若有一元素想往int[n]的第k个位置插入数据，需要在k-n的位置往后移。\n"),s("strong",[t._v("最好情况时间复杂度 O(1)")]),t._v(" "),s("strong",[t._v("最坏情况复杂度为O(n)")]),t._v(" "),s("strong",[t._v("平均负责度为O(n)")])]),t._v(" "),s("p",[t._v("如果数组中的数据不是有序的，也就是无规律的情况下，可以直接把第k个位置上的数据移到最后，然后将插入的数据直接放在第k个位置上。")]),t._v(" "),s("p",[t._v("这样时间复杂度就将为 O（1）了。")]),t._v(" "),s("h6",{attrs:{id:"删除："}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除："}},[t._v("#")]),t._v(" "),s("strong",[t._v("删除：")])]),t._v(" "),s("p",[t._v("与插入类似，为了保持内存的连续性。\n"),s("strong",[t._v("最好情况时间复杂度 O(1)")]),t._v(" "),s("strong",[t._v("最坏情况复杂度为O(n)")]),t._v(" "),s("strong",[t._v("平均负责度为O(n)")])]),t._v(" "),s("p",[s("strong",[t._v("提高效率")]),t._v("：将多次删除操作中集中在一起执行，可以先记录已经删除的数据，但是不进行数据迁移，而仅仅是记录，当发现没有更多空间存储时，再执行真正的删除操作。这也是 JVM 标记清除垃圾回收算法的核心思想。")]),t._v(" "),s("h5",{attrs:{id:"数组访问越界问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组访问越界问题"}},[t._v("#")]),t._v(" "),s("strong",[t._v("数组访问越界问题")])]),t._v(" "),s("p",[t._v("C语言中的数据越界是一种未决行为，一般比较难发现的逻辑错误。相比之下，Java会有越界检查。")]),t._v(" "),s("h5",{attrs:{id:"用数组还是容器？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#用数组还是容器？"}},[t._v("#")]),t._v(" 用数组还是容器？")]),t._v(" "),s("p",[t._v("数组先指定了空间大小\n容器如ArrayList可以动态扩容。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("希望存储基本类型数据，可以用数组")])]),t._v(" "),s("li",[s("p",[t._v("事先知道数据大小，并且操作简单，可以用数组")])]),t._v(" "),s("li",[s("p",[t._v("直观表示多维，可以用数组")])]),t._v(" "),s("li",[s("p",[t._v("业务开发，使用容器足够，开发框架，追求性能，首先数组。")])])])])}),[],!1,null,null,null);a.default=v.exports}}]);