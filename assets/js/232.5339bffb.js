(window.webpackJsonp=window.webpackJsonp||[]).push([[232],{653:function(e,n,s){"use strict";s.r(n);var t=s(30),r=Object(t.a)({},(function(){var e=this.$createElement,n=this._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("p",[this._v("服务端")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v('import socket\nimport struct\nimport json\nimport subprocess\nimport os\n\nclass MYTCPServer:\n    address_family = socket.AF_INET\n\n    socket_type = socket.SOCK_STREAM\n\n    allow_reuse_address = False\n\n    max_packet_size = 8192\n\n    coding=\'utf-8\'\n\n    request_queue_size = 5\n\n    server_dir=\'file_upload\'\n\n    def __init__(self, server_address, bind_and_activate=True):\n        """Constructor.  May be extended, do not override."""\n        self.server_address=server_address\n        self.socket = socket.socket(self.address_family,\n                                    self.socket_type)\n        if bind_and_activate:\n            try:\n                self.server_bind()\n                self.server_activate()\n            except:\n                self.server_close()\n                raise\n\n    def server_bind(self):\n        """Called by constructor to bind the socket.\n        """\n        if self.allow_reuse_address:\n            self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        self.socket.bind(self.server_address)\n        self.server_address = self.socket.getsockname()\n\n    def server_activate(self):\n        """Called by constructor to activate the server.\n        """\n        self.socket.listen(self.request_queue_size)\n\n    def server_close(self):\n        """Called to clean-up the server.\n        """\n        self.socket.close()\n\n    def get_request(self):\n        """Get the request and client address from the socket.\n        """\n        return self.socket.accept()\n\n    def close_request(self, request):\n        """Called to clean up an individual request."""\n        request.close()\n\n    def run(self):\n        while True:\n            self.conn,self.client_addr=self.get_request()\n            print(\'from client \',self.client_addr)\n            while True:\n                try:\n                    head_struct = self.conn.recv(4)\n                    if not head_struct:break\n\n                    head_len = struct.unpack(\'i\', head_struct)[0]\n                    head_json = self.conn.recv(head_len).decode(self.coding)\n                    head_dic = json.loads(head_json)\n\n                    print(head_dic)\n                    #head_dic={\'cmd\':\'put\',\'filename\':\'a.txt\',\'filesize\':123123}\n                    cmd=head_dic[\'cmd\']\n                    if hasattr(self,cmd):\n                        func=getattr(self,cmd)\n                        func(head_dic)\n                except Exception:\n                    break\n\n    def put(self,args):\n        file_path=os.path.normpath(os.path.join(\n            self.server_dir,\n            args[\'filename\']\n        ))\n\n        filesize=args[\'filesize\']\n        recv_size=0\n        print(\'-----\x3e\',file_path)\n        with open(file_path,\'wb\') as f:\n            while recv_size < filesize:\n                recv_data=self.conn.recv(self.max_packet_size)\n                f.write(recv_data)\n                recv_size+=len(recv_data)\n                print(\'recvsize:%s filesize:%s\' %(recv_size,filesize))\n\n\ntcpserver1=MYTCPServer((\'127.0.0.1\',8080))\n\ntcpserver1.run()\n')])])]),n("p",[this._v("客户端")]),this._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("import socket\nimport struct\nimport json\nimport os\n\n\n\nclass MYTCPClient:\n    address_family = socket.AF_INET\n\n    socket_type = socket.SOCK_STREAM\n\n    allow_reuse_address = False\n\n    max_packet_size = 8192\n\n    coding='utf-8'\n\n    request_queue_size = 5\n\n    def __init__(self, server_address, connect=True):\n        self.server_address=server_address\n        self.socket = socket.socket(self.address_family,\n                                    self.socket_type)\n        if connect:\n            try:\n                self.client_connect()\n            except:\n                self.client_close()\n                raise\n\n    def client_connect(self):\n        self.socket.connect(self.server_address)\n\n    def client_close(self):\n        self.socket.close()\n\n    def run(self):\n        while True:\n            inp=input(\">>: \").strip()\n            if not inp:continue\n            l=inp.split()\n            cmd=l[0]\n            if hasattr(self,cmd):\n                func=getattr(self,cmd)\n                func(l)\n\n\n    def put(self,args):\n        cmd=args[0]\n        filename=args[1]\n        if not os.path.isfile(filename):\n            print('file:%s is not exists' %filename)\n            return\n        else:\n            filesize=os.path.getsize(filename)\n\n        head_dic={'cmd':cmd,'filename':os.path.basename(filename),'filesize':filesize}\n        print(head_dic)\n        head_json=json.dumps(head_dic)\n        head_json_bytes=bytes(head_json,encoding=self.coding)\n\n        head_struct=struct.pack('i',len(head_json_bytes))\n        self.socket.send(head_struct)\n        self.socket.send(head_json_bytes)\n        send_size=0\n        with open(filename,'rb') as f:\n            for line in f:\n                self.socket.send(line)\n                send_size+=len(line)\n                print(send_size)\n            else:\n                print('upload successful')\n\n\n\n\nclient=MYTCPClient(('127.0.0.1',8080))\n\nclient.run()\n")])])])])}),[],!1,null,null,null);n.default=r.exports}}]);