(window.webpackJsonp=window.webpackJsonp||[]).push([[240],{661:function(_,v,s){"use strict";s.r(v);var t=s(30),e=Object(t.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("p",[s("strong",[_._v("继承")])]),_._v(" "),s("p",[s("strong",[_._v("什么是继承？")])]),_._v(" "),s("p",[_._v("继承指的是类与类之间的关系，是一种什么是什么的关系，继承的功能之一就是用来解决代码重用问题")]),_._v(" "),s("p",[_._v("继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类的属性和方法，父类又可以成为基类或超类，新建的类称为派生类或子类，")]),_._v(" "),s("p",[s("strong",[_._v("查看继承")])]),_._v(" "),s("p",[_._v("class."),s("strong",[_._v("bases")]),_._v("#__base__只查看从左到右继承的第一个子类，__bases__则是查看所有继承的父类")]),_._v(" "),s("p",[s("strong",[_._v("继承的查找顺序")])]),_._v(" "),s("p",[_._v("先在自己对象里找，然后去类里找，最后去父类里去找")]),_._v(" "),s("p",[_._v("哪一个对象调用，self就是代指的哪一个对象，(父类，子类里的self，都是对象)")]),_._v(" "),s("p",[s("strong",[_._v("经典类与新式类")])]),_._v(" "),s("p",[_._v("经典类，广度优先，没有继承object的类，以及它的子类都称之为经典类，没有mro方法，一条道走到黑，新式类，深度优先，继承object的类，以及它的子类都称之为新式类，有一个内置方法."),s("strong",[_._v("mro")]),_._v("( ) python3 都是新式类，一个类没有继承object类，其实是默认继承python2 新式类，经典类")]),_._v(" "),s("p",[_._v("继承与抽象")]),_._v(" "),s("p",[_._v("抽象即抽取类似或者说比较像的部分。")]),_._v(" "),s("p",[_._v("抽象分成两个层次：")]),_._v(" "),s("p",[_._v("1.将奥巴马和梅西这俩对象比较像的部分抽取成类；")]),_._v(" "),s("p",[_._v("2.将人，猪，狗这三个类比较像的部分抽取成父类。")]),_._v(" "),s("p",[_._v("抽象最主要的作用是划分类别（可以隔离关注点，降低复杂度）")]),_._v(" "),s("img",{attrs:{src:"https://images2018.cnblogs.com/blog/1151928/201806/1151928-20180604214031113-516969389.png",alt:""}}),_._v(" "),s("p",[_._v("继承：是基于抽象的结果，通过编程语言去实现它，肯定是先经历抽象这个过程，才能通过继承的方式去表达出抽象的结构。")]),_._v(" "),s("p",[s("strong",[_._v("在子类中重用父类的属性")]),_._v("方式一指名道姓： (不依赖继承)新方法下执行")]),_._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v("def new():\n    父类.方法（）\n    父类.__init__() #调用父类的init方法\n")])])]),s("p",[_._v("方式二super()  (依赖继承)super(自己类名，self).方法() 得到一个父类的对象super(自己类名，self)."),s("strong",[_._v("init")]),_._v("()python3简写为super().方法()super()从mro列表当前位置往后去找，")]),_._v(" "),s("p",[_._v("组合")]),_._v(" "),s("p",[_._v("组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合")]),_._v(" "),s("p",[_._v("一个类的对象与另一个类的对象组合与继承的区别在与，组合根据什么有什么的关系，而继承是根据什么是什么的关系，")]),_._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[_._v(">>> class Equip: #武器装备类\n...     def fire(self):\n...         print('release Fire skill')\n... \n>>> class Riven: #英雄Riven的类,一个英雄需要有装备,因而需要组合Equip类\n...     camp='Noxus'\n...     def __init__(self,nickname):\n...         self.nickname=nickname\n...         self.equip=Equip() #用Equip类产生一个装备,赋值给实例的equip属性\n... \n>>> r1=Riven('锐雯雯')\n>>> r1.equip.fire() #可以使用组合的类产生的对象所持有的方法\nrelease Fire skill\n")])])]),s("p",[s("strong",[_._v("抽象类与归一化")]),_._v("规范化子类的方法抽取多个类的相似部分，集成到一个父类里，让它们都去继承父类让子类继承的时候必须实现父类规定的方法抽象类本质上也是一个类，有其他父类的特性抽象类只能被继承，不能被实例化import abcclass animal(metaclass=abc.ABCMeta)\t@abc.abstractmethod\tdef eat()     以后继承此类的子类，必须写此方法")]),_._v(" "),s("p",[_._v("多态性：指的是可以在不考虑对象的类型的情况下直接使用对象鸭子类型：只要你的方法看起来像鸭子，那么我就认为你是鸭子，不用一定要继承父类，只要做得像一点就OK")]),_._v(" "),s("p",[s("strong",[_._v("封装")])]),_._v(" "),s("p",[_._v("封装之隐藏在方法，属性前加下划线进行隐藏在类定义时，对下划线开头的属性进行变形_class_type这种变形的特点：1，在类外部无法直接obj._attrName2，在类内部是可以直接使用obj._AttrName3, 子类无法覆盖父类_开头的属性")]),_._v(" "),s("p",[_._v("保护对象的属性：")]),_._v(" "),s("p",[_._v("如果有一个对象，当需要对其进行修改属性时，有2种方法")]),_._v(" "),s("ul",[s("li",[_._v("对象名.属性名 = 数据 ----\x3e直接修改")]),_._v(" "),s("li",[_._v("对象名.方法名() ----\x3e间接修改")])]),_._v(" "),s("p",[_._v("为了更好的保存属性安全，即不能随意修改，一般的处理方式为")]),_._v(" "),s("ul",[s("li",[_._v("将属性定义为私有属性")]),_._v(" "),s("li",[_._v("添加一个可以调用的方法，供调用")])]),_._v(" "),s("p",[_._v("封装数据属性：明确的区分内外，")]),_._v(" "),s("p",[_._v("绑定方法与非绑定方法在类定义的函数分为两大类：一类：绑定方法（绑定给谁，就应该有谁来调用，谁来调用，就会把调用者当做第一个参数传入）\t绑定到对象法:在类内定义的没有被任何装饰器修饰的\t绑定到类的方法:在类定义的被classmethod修饰的方法。传入（cls）参数cls=该类\t在方法前加入@classmethod二类：非绑定方法 （没有自动传值这么一说，就是类中定义的一个工具，类和对象都可以使用）\t既不与类绑定也不与对象绑定\t在方法前加入@staticmethod")])])}),[],!1,null,null,null);v.default=e.exports}}]);