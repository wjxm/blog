(window.webpackJsonp=window.webpackJsonp||[]).push([[242],{663:function(e,n,t){"use strict";t.r(n);var r=t(30),i=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("本节导读：")]),e._v(" "),t("ul",[t("li",[e._v("什么是线程")]),e._v(" "),t("li",[e._v("线程与进程的区别")]),e._v(" "),t("li",[e._v("开启线程的两种方法")]),e._v(" "),t("li",[e._v("多线程与多进程的区别")]),e._v(" "),t("li",[e._v("thread对象的其他属性")]),e._v(" "),t("li",[e._v("守护线程")]),e._v(" "),t("li",[e._v("gil全局解释器锁")]),e._v(" "),t("li",[e._v("死锁现象与递归锁")]),e._v(" "),t("li",[e._v("信号量，event，定时器")]),e._v(" "),t("li",[e._v("线程queue")]),e._v(" "),t("li",[e._v("进程池与线程池")])]),e._v(" "),t("p",[e._v("一 什么是线程")]),e._v(" "),t("p",[e._v("线程顾名思义，就是一条流水线工作的过程（流水线的工作需要电源，电源就相当于cpu），而一条流水线必须属于一个车间，一个车间的工作过程是一个进程，车间负责把资源整合到一起，是一个资源单位，而一个车间内至少有一条流水线。")]),e._v(" "),t("p",[e._v("所以，进程只是用来把资源集中到一起（进程只是一个资源单位，或者说资源集合），而线程才是cpu上的执行单位。")]),e._v(" "),t("p",[e._v("多线程（即多个控制线程）的概念是，在一个进程中存在多个线程，多个线程共享该进程的地址空间，相当于一个车间内有多条流水线，都共用一个车间的资源。例如，北京地铁与上海地铁是不同的进程，而北京地铁里的13号线是一个线程，北京地铁所有的线路共享北京地铁所有的资源，比如所有的乘客可以被所有线路拉。")]),e._v(" "),t("p",[e._v("二 线程与进程的区别")]),e._v(" "),t("ul",[t("li",[e._v("同一个进程内的多个线程共享该进程内的地址资源")]),e._v(" "),t("li",[e._v("创建线程的开销要远小于创建进程的开销（创建一个进程，就是创建一个车间，涉及到申请空间，而且在该空间内建至少一条流水线，但创建线程，就只是在一个车间内造一条流水线，无需申请空间，所以创建开销小）")])]),e._v(" "),t("p",[e._v("三 开启线程的两种方法")]),e._v(" "),t("p",[e._v("threading模块介绍")]),e._v(" "),t("p",[e._v("multiprocess模块的完全模仿了threading模块的接口，二者在使用层面，有很大的相似性，因而不再详细介绍")]),e._v(" "),t("p",[e._v("方式一")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("from threading import Thread\nimport time\n\ndef sayhi(name):\n    time.sleep(2)\n    print('%s say hello' %name)\n\nif __name__ == '__main__':\n    t=Thread(target=sayhi,args=('egon',))\n    t.start()\n    print('主线程')\n")])])]),t("p",[e._v("方式二")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("from threading import Thread\nimport time\n\nclass Sayhi(Thread):\n    def __init__(self,name):\n        super().__init__()\n        self.name=name\n    def run(self):\n        time.sleep(2)\n        print('%s say hello' % self.name)\n\nif __name__ == '__main__':\n    t = Sayhi('egon')\n    t.start()\n    print('主线程')\n")])])]),t("p",[e._v("四 多线程与多进程的区别")]),e._v(" "),t("h3",{attrs:{id:"开启速度"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#开启速度"}},[e._v("#")]),e._v(" 开启速度")]),e._v(" "),t("p",[e._v("在主进程下开启线程，几乎是t.start ()的同时就将线程开启了，说明开销极小")]),e._v(" "),t("p",[e._v("在主进程下开子进程，p.start ()将开启进程的信号发给操作系统后，操作系统要申请内存空间，让好拷贝父进程地址空间到子进程，开销远大于线程")]),e._v(" "),t("p",[t("strong",[e._v("pid")])]),e._v(" "),t("p",[e._v("在主进程下开启多个线程,每个线程都跟主进程的pid一样")]),e._v(" "),t("p",[e._v("开多个进程,每个进程都有不同的pid")]),e._v(" "),t("p",[t("strong",[e._v("数据共享")])]),e._v(" "),t("p",[e._v("进程之间地址空间是隔离的")]),e._v(" "),t("p",[e._v("同一进程内开启的多个线程是共享该进程地址空间的")]),e._v(" "),t("p",[e._v("五 thread对象的其他属性")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Thread实例对象的方法\n  # isAlive(): 返回线程是否活动的。\n  # getName(): 返回线程名。\n  # setName(): 设置线程名。\n\nthreading模块提供的一些方法：\n  # threading.currentThread(): 返回当前的线程变量。\n  # threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。\n  # threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。\n")])])]),t("p",[e._v("六 守护线程")]),e._v(" "),t("p",[e._v("无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁")]),e._v(" "),t("p",[e._v("需要强调的是：运行完毕并非终止运行")]),e._v(" "),t("p",[t("code",[e._v("对主进程来说，运行完毕指的是主进程代码运行完毕，")])]),e._v(" "),t("p",[t("code",[e._v("对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕，")])]),e._v(" "),t("p",[e._v("```主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，`")]),e._v(" "),t("p",[e._v("```主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。`")]),e._v(" "),t("p",[e._v("七 gil全局解释器锁")]),e._v(" "),t("p",[e._v("首先需要明确的一点是GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。>有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把GIL归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL")]),e._v(" "),t("p",[e._v("八 死锁现象与递归锁")]),e._v(" "),t("p",[e._v("死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("from threading import Thread,Lock\nimport time\nmutexA=Lock()\nmutexB=Lock()\n\nclass MyThread(Thread):\n    def run(self):\n        self.func1()\n        self.func2()\n    def func1(self):\n        mutexA.acquire()\n        print('\\033[41m%s 拿到A锁\\033[0m' %self.name)\n\n        mutexB.acquire()\n        print('\\033[42m%s 拿到B锁\\033[0m' %self.name)\n        mutexB.release()\n\n        mutexA.release()\n\n    def func2(self):\n        mutexB.acquire()\n        print('\\033[43m%s 拿到B锁\\033[0m' %self.name)\n        time.sleep(2)\n\n        mutexA.acquire()\n        print('\\033[44m%s 拿到A锁\\033[0m' %self.name)\n        mutexA.release()\n\n        mutexB.release()\n\nif __name__ == '__main__':\n    for i in range(10):\n        t=MyThread()\n        t.start()\n")])])]),t("p",[e._v("递归锁")]),e._v(" "),t("p",[e._v("递归锁，死锁的解决方案，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。")]),e._v(" "),t("p",[e._v("这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁，二者的区别是：递归锁可以连续acquire多次，而互斥锁只能acquire一次")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("from threading import Thread,RLock\nimport time\n\nmutexA=mutexB=RLock() #一个线程拿到锁，counter加1,该线程内又碰到加锁的情况，则counter继续加1，这期间所有其他线程都只能等待，等待该线程释放所有锁，即counter递减到0为止\n\nclass MyThread(Thread):\n    def run(self):\n        self.func1()\n        self.func2()\n    def func1(self):\n        mutexA.acquire()\n        print('\\033[41m%s 拿到A锁\\033[0m' %self.name)\n\n        mutexB.acquire()\n        print('\\033[42m%s 拿到B锁\\033[0m' %self.name)\n        mutexB.release()\n\n        mutexA.release()\n\n    def func2(self):\n        mutexB.acquire()\n        print('\\033[43m%s 拿到B锁\\033[0m' %self.name)\n        time.sleep(2)\n\n        mutexA.acquire()\n        print('\\033[44m%s 拿到A锁\\033[0m' %self.name)\n        mutexA.release()\n\n        mutexB.release()\n\nif __name__ == '__main__':\n    for i in range(10):\n        t=MyThread()\n        t.start()\n")])])]),t("p",[e._v("九 信号量，event，定时器")]),e._v(" "),t("p",[e._v("信号量")]),e._v(" "),t("p",[e._v("信号量也是一把锁，可以指定信号量为5，对比互斥锁同一时间只能有一个任务抢到锁去执行，信号量同一时间可以有5个任务拿到锁去执行，如果说互斥锁是合租房屋的人去抢一个厕所，那么信号量就相当于一群路人争抢公共厕所，公共厕所有多个坑位，这意味着同一时间可以有多个人上公共厕所，但公共厕所容纳的人数是一定的，这便是信号量的大小")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("from threading import Thread,Semaphore\nimport threading\nimport time\n\ndef func():\n    sm.acquire()\n    print('%s get sm' %threading.current_thread().getName())\n    time.sleep(3)\n    sm.release()\n\nif __name__ == '__main__':\n    sm=Semaphore(5)\n    for i in range(23):\n        t=Thread(target=func)\n        t.start()\n\n#Semaphore管理一个内置的计数器，每当调用acquire()时内置计数器-1；调用release() 时内置计数器+1；计数器不能小于0；当计数器为0时acquire()将阻塞线程直到其他线程调用release()。\n")])])]),t("p",[e._v("event")]),e._v(" "),t("p",[e._v("线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。 对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在 初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<code style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; user-select: text !important; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.85em; padding: 0px; color: inherit; background: 0px 0px; border-radius: 0px; white-space: pre; break-inside: avoid; direction: ltr; margin: 0px; border: none; display: inline; max-width: initial; overflow: initial; line-height: inherit;\">from threading import Event\n\nevent.isSet()：返回event的状态值；\n\nevent.wait()：如果 event.isSet()==False将阻塞线程；\n\nevent.set()： 设置event的状态值为True，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；\n\nevent.clear()：恢复event的状态值为False。\n</code>\n")])])]),t("img",{staticStyle:{"box-sizing":"border-box","-webkit-tap-highlight-color":"transparent","text-size-adjust":"none","-webkit-font-smoothing":"antialiased","vertical-align":"middle","font-size":"inherit","break-inside":"avoid","max-width":"100%","user-select":"text !important"},attrs:{src:"https://www.luffycity.com/python-book/assets/chapter7/Event.png",alt:""}}),e._v(" "),t("p",[e._v("例如，有多个工作线程尝试链接MySQL，我们想要在链接前确保MySQL服务正常才让那些工作线程去连接MySQL服务器，如果连接不成功，都会去尝试重新连接。那么我们就可以采用threading.Event机制来协调各个工作线程的连接操作")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<code style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; user-select: text !important; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.85em; padding: 0px; color: inherit; background: 0px 0px; border-radius: 0px; white-space: pre; break-inside: avoid; direction: ltr; margin: 0px; border: none; display: inline; max-width: initial; overflow: initial; line-height: inherit;\">from threading import Thread,Event\nimport threading\nimport time,random\ndef conn_mysql():\n    count=1\n    while not event.is_set():\n        if count > 3:\n            raise TimeoutError('链接超时')\n        print('<%s>第%s次尝试链接' % (threading.current_thread().getName(), count))\n        event.wait(0.5)\n        count+=1\n    print('<%s>链接成功' %threading.current_thread().getName())\n\n\ndef check_mysql():\n    print('\\033[45m[%s]正在检查mysql\\033[0m' % threading.current_thread().getName())\n    time.sleep(random.randint(2,4))\n    event.set()\nif __name__ == '__main__':\n    event=Event()\n    conn1=Thread(target=conn_mysql)\n    conn2=Thread(target=conn_mysql)\n    check=Thread(target=check_mysql)\n\n    conn1.start()\n    conn2.start()\n    check.start()</code>\n")])])]),t("p",[e._v("定时器")]),e._v(" "),t("p",[e._v("定时器，指定n秒后执行某操作")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<code style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; user-select: text !important; font-family: Consolas, \'Liberation Mono\', Menlo, Courier, monospace; font-size: 0.85em; padding: 0px; color: inherit; background: 0px 0px; border-radius: 0px; white-space: pre; break-inside: avoid; direction: ltr; margin: 0px; border: none; display: inline; max-width: initial; overflow: initial; line-height: inherit;">from threading import Timer\n\ndef hello():\n    print("hello, world")\n\nt = Timer(1, hello)\nt.start()  # after 1 seconds, "hello, world" will be printed</code>\n')])])]),t("p",[e._v("十 线程queue")]),e._v(" "),t("p",[e._v("有三种不同的用法")]),e._v(" "),t("p",[e._v("class queue.Queue(maxsize=0) #队列：先进先出")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<code style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; user-select: text !important; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.85em; padding: 0px; color: inherit; background: 0px 0px; border-radius: 0px; white-space: pre; break-inside: avoid; direction: ltr; margin: 0px; border: none; display: inline; max-width: initial; overflow: initial; line-height: inherit;\">import queue\n\nq=queue.Queue()\nq.put('first')\nq.put('second')\nq.put('third')\n\nprint(q.get())\nprint(q.get())\nprint(q.get())\n\n\n\n'''\n结果(先进先出):\nfirst\nsecond\nthird\n'''\n</code>\n")])])]),t("p",[e._v("class queue.LifoQueue(maxsize=0) #堆栈：last in fisrt out")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<code style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; user-select: text !important; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.85em; padding: 0px; color: inherit; background: 0px 0px; border-radius: 0px; white-space: pre; break-inside: avoid; direction: ltr; margin: 0px; border: none; display: inline; max-width: initial; overflow: initial; line-height: inherit;\">import queue\n\nq=queue.LifoQueue()\nq.put('first')\nq.put('second')\nq.put('third')\n\nprint(q.get())\nprint(q.get())\nprint(q.get())\n\n\n\n'''\n结果(后进先出):\nthird\nsecond\nfirst\n'''\n</code>\n")])])]),t("p",[e._v("class queue.PriorityQueue(maxsize=0) #优先级队列：存储数据时可设置优先级的队列")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<code style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; user-select: text !important; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.85em; padding: 0px; color: inherit; background: 0px 0px; border-radius: 0px; white-space: pre; break-inside: avoid; direction: ltr; margin: 0px; border: none; display: inline; max-width: initial; overflow: initial; line-height: inherit;\">import queue\n\nq=queue.PriorityQueue()\n#put进入一个元组,元组的第一个元素是优先级(通常是数字,也可以是非数字之间的比较),数字越小优先级越高\nq.put((20,'a'))\nq.put((10,'b'))\nq.put((30,'c'))\n\nprint(q.get())\nprint(q.get())\nprint(q.get())\n\n\n\n'''\n结果(数字越小优先级越高,优先级高的优先出队):\n(10, 'b')\n(20, 'a')\n(30, 'c')\n'''</code>\n")])])]),t("p",[e._v("十一 进程池与线程池")]),e._v(" "),t("p",[e._v("在刚开始学多进程或多线程时，我们迫不及待地基于多进程或多线程实现并发的套接字通信，然而这种实现方式的致命缺陷是：服务的开启的进程数或线程数都会随着并发的客户端数目地增多而增多，这会对服务端主机带来巨大的压力，甚至于不堪重负而瘫痪，于是我们必须对服务端开启的进程数或线程数加以控制，让机器在一个自己可以承受的范围内运行，这就是进程池或线程池的用途，例如进程池，就是用来存放进程的池子，本质还是基于多进程，只不过是对开启进程的数目加上了限制")]),e._v(" "),t("p",[e._v("介绍")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<code style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; user-select: text !important; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.85em; padding: 0px; color: inherit; background: 0px 0px; border-radius: 0px; white-space: pre; break-inside: avoid; direction: ltr; margin: 0px; border: none; display: inline; max-width: initial; overflow: initial; line-height: inherit;\">官网：https://docs.python.org/dev/library/concurrent.futures.html\n\nconcurrent.futures模块提供了高度封装的异步调用接口\nThreadPoolExecutor：线程池，提供异步调用\nProcessPoolExecutor: 进程池，提供异步调用\nBoth implement the same interface, which is defined by the abstract Executor class.\n</code>\n")])])]),t("p",[e._v("基本方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<code style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; user-select: text !important; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.85em; padding: 0px; color: inherit; background: 0px 0px; border-radius: 0px; white-space: pre; break-inside: avoid; direction: ltr; margin: 0px; border: none; display: inline; max-width: initial; overflow: initial; line-height: inherit;\">1、submit(fn, *args, **kwargs)\n异步提交任务\n\n2、map(func, *iterables, timeout=None, chunksize=1) \n取代for循环submit的操作\n\n3、shutdown(wait=True) \n相当于进程池的pool.close()+pool.join()操作\nwait=True，等待池内所有任务执行完毕回收完资源后才继续\nwait=False，立即返回，并不会等待池内的任务执行完毕\n但不管wait参数为何值，整个程序都会等到所有任务执行完毕\nsubmit和map必须在shutdown之前\n\n4、result(timeout=None)\n取得结果\n\n5、add_done_callback(fn)\n回调函数\n</code>\n")])])]),t("h3",{attrs:{id:"进程池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程池"}},[e._v("#")]),e._v(" "),t("strong",[e._v("进程池")])]),e._v(" "),t("h3",{attrs:{id:"用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[e._v("#")]),e._v(" "),t("code",[e._v("用法")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutor\n\nimport os,time,random\ndef task(n):\n    print('%s is runing' %os.getpid())\n    time.sleep(random.randint(1,3))\n    return n**2\n\nif __name__ == '__main__':\n\n    executor=ProcessPoolExecutor(max_workers=3)\n\n    futures=[]\n    for i in range(11):\n        future=executor.submit(task,i)\n        futures.append(future)\n    executor.shutdown(True)\n    print('+++>')\n    for future in futures:\n        print(future.result())\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("``\n")])])]),t("h3",{attrs:{id:"线程池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程池"}},[e._v("#")]),e._v(" 线程池")]),e._v(" "),t("p",[e._v("用法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<code style=\"box-sizing: border-box; -webkit-tap-highlight-color: transparent; text-size-adjust: none; -webkit-font-smoothing: antialiased; user-select: text !important; font-family: Consolas, 'Liberation Mono', Menlo, Courier, monospace; font-size: 0.85em; padding: 0px; color: inherit; background: 0px 0px; border-radius: 0px; white-space: pre; break-inside: avoid; direction: ltr; margin: 0px; border: none; display: inline; max-width: initial; overflow: initial; line-height: inherit;\">把ProcessPoolExecutor换成ThreadPoolExecutor，其余用法全部相同\n</code>\n")])])]),t("h3",{attrs:{id:"map方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map方法"}},[e._v("#")]),e._v(" map方法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutor\n\nimport os,time,random\ndef task(n):\n    print('%s is runing' %os.getpid())\n    time.sleep(random.randint(1,3))\n    return n**2\n\nif __name__ == '__main__':\n\n    executor=ThreadPoolExecutor(max_workers=3)\n\n    # for i in range(11):\n    #     future=executor.submit(task,i)\n\n    executor.map(task,range(1,12)) #map取代了for+submit\n")])])]),t("h3",{attrs:{id:"回调函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#回调函数"}},[e._v("#")]),e._v(" 回调函数")]),e._v(" "),t("p",[e._v("可以为进程池或线程池内的每个进程或线程绑定一个函数，该函数在进程或线程的任务执行完毕后自动触发，并接收任务的返回值当作参数，该函数称为回调函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutor\nfrom multiprocessing import Pool\nimport requests\nimport json\nimport os\n\ndef get_page(url):\n    print('<进程%s> get %s' %(os.getpid(),url))\n    respone=requests.get(url)\n    if respone.status_code == 200:\n        return {'url':url,'text':respone.text}\n\ndef parse_page(res):\n    res=res.result()\n    print('<进程%s> parse %s' %(os.getpid(),res['url']))\n    parse_res='url:<%s> size:[%s]\\n' %(res['url'],len(res['text']))\n    with open('db.txt','a') as f:\n        f.write(parse_res)\n\n\nif __name__ == '__main__':\n    urls=[\n        'https://www.baidu.com',\n        'https://www.python.org',\n        'https://www.openstack.org',\n        'https://help.github.com/',\n        'http://www.sina.com.cn/'\n    ]\n\n    p=ProcessPoolExecutor(3)\n    for url in urls:\n        p.submit(get_page,url).add_done_callback(parse_page) #parse_page拿到的是一个future对象obj，需要用obj.result()拿到结果\n")])])])])}),[],!1,null,null,null);n.default=i.exports}}]);