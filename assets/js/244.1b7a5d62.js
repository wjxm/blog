(window.webpackJsonp=window.webpackJsonp||[]).push([[244],{665:function(e,n,t){"use strict";t.r(n);var a=t(30),i=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("本节导读：")]),e._v(" "),t("ul",[t("li",[e._v("协程介绍")]),e._v(" "),t("li",[e._v("greenle模块")]),e._v(" "),t("li",[e._v("gevent模块")])]),e._v(" "),t("p",[e._v("一 协程介绍")]),e._v(" "),t("p",[e._v("协程：是单线程下的并发，又称微线程，纤程。英文名Coroutine。一句话说明什么是线程：协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。、")]),e._v(" "),t("p",[e._v("需要强调的是：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）")])]),e._v(" "),t("li",[e._v("```单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关）`")])]),e._v(" "),t("p",[e._v("对比操作系统控制线程的切换，用户在单线程内控制协程的切换")]),e._v(" "),t("p",[e._v("优点如下：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("协程的切换开销更小，属于程序级别的切换，操作系统完全感知不到，因而更加轻量级")])]),e._v(" "),t("li",[e._v("```单线程内就可以实现并发的效果，最大限度地利用cpu`")])]),e._v(" "),t("p",[e._v("缺点如下：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("协程的本质是单线程下，无法利用多核，可以是一个程序开启多个进程，每个进程内开启多个线程，每个线程内开启协程")])]),e._v(" "),t("li",[e._v("```协程指的是单个线程，因而一旦协程出现阻塞，将会阻塞整个线程`")])]),e._v(" "),t("p",[e._v("总结：")]),e._v(" "),t("ol",[t("li",[e._v("必须在只有一个单线程里实现并发")]),e._v(" "),t("li",[e._v("修改共享数据不需加锁")]),e._v(" "),t("li",[e._v("用户程序里自己保存多个控制流的上下文栈")]),e._v(" "),t("li",[e._v("附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））")])]),e._v(" "),t("p",[e._v("二 greenlet模块")]),e._v(" "),t("p",[e._v("如果我们在单个线程内有20个任务，要想实现在多个任务之间切换，使用yield生成器的方式过于麻烦（需要先得到初始化一次的生成器，然后再调用send。。。非常麻烦），而使用greenlet模块可以非常简单地实现这20个任务直接的切换")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#安装：pip3 install greenlet\nfrom greenlet import greenlet\n\ndef eat(name):\n    print('%s eat 1' %name)\n    g2.switch('egon')\n    print('%s eat 2' %name)\n    g2.switch()\ndef play(name):\n    print('%s play 1' %name)\n    g1.switch()\n    print('%s play 2' %name)\n\ng1=greenlet(eat)\ng2=greenlet(play)\n\ng1.switch('egon')#可以在第一次switch时传入参数，以后都不需要\n\n#单纯的切换（在没有io的情况下或者没有重复开辟内存空间的操作），反而会降低程序的执行速度\n\n#顺序执行\nimport time\ndef f1():\n    res=1\n    for i in range(100000000):\n        res+=i\n\ndef f2():\n    res=1\n    for i in range(100000000):\n        res*=i\n\nstart=time.time()\nf1()\nf2()\nstop=time.time()\nprint('run time is %s' %(stop-start)) #10.985628366470337\n\n#切换\nfrom greenlet import greenlet\nimport time\ndef f1():\n    res=1\n    for i in range(100000000):\n        res+=i\n        g2.switch()\n\ndef f2():\n    res=1\n    for i in range(100000000):\n        res*=i\n        g1.switch()\n\nstart=time.time()\ng1=greenlet(f1)\ng2=greenlet(f2)\ng1.switch()\nstop=time.time()\nprint('run time is %s' %(stop-start)) # 52.763017892837524\n")])])]),t("p",[e._v("greenlet只是提供了一种比generator更加便捷的切换方式，当切到一个任务执行时如果遇到io，那就原地阻塞，仍然是没有解决遇到IO自动切换来提升效率的问题。")]),e._v(" "),t("p",[e._v("单线程里的这20个任务的代码通常会既有计算操作又有阻塞操作，我们完全可以在执行任务1时遇到阻塞，就利用阻塞的时间去执行任务2。。。。如此，才能提高效率，这就用到了Gevent模块。")]),e._v(" "),t("p",[e._v("三 gevent模块")]),e._v(" "),t("p",[e._v("Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("#用法\ng1=gevent.spawn(func,1,,2,3,x=4,y=5)创建一个协程对象g1，spawn括号内第一个参数是函数名，如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的\n\ng2=gevent.spawn(func2)\n\ng1.join() #等待g1结束\n\ng2.join() #等待g2结束\n\n#或者上述两步合作一步：gevent.joinall([g1,g2])\n\ng1.value#拿到func1的返回值\n")])])]),t("p",[e._v("遇到IO阻塞时会自动切换任务")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("import gevent\ndef eat(name):\n    print('%s eat 1' %name)\n    gevent.sleep(2)\n    print('%s eat 2' %name)\n\ndef play(name):\n    print('%s play 1' %name)\n    gevent.sleep(1)\n    print('%s play 2' %name)\n\n\ng1=gevent.spawn(eat,'egon')\ng2=gevent.spawn(play,name='egon')\ng1.join()\ng2.join()\n#或者gevent.joinall([g1,g2])\nprint('主')\n")])])]),t("p",[e._v("上例gevent.sleep(2)模拟的是gevent可以识别的io阻塞,")]),e._v(" "),t("p",[e._v("而time.sleep(2)或其他的阻塞,gevent是不能直接识别的需要用下面一行代码,打补丁,就可以识别了")]),e._v(" "),t("p",[e._v("from gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前")]),e._v(" "),t("p",[e._v("或者我们干脆记忆成：要用gevent，需要将from gevent import monkey;monkey.patch_all()放到文件的开头")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("from gevent import monkey;monkey.patch_all()\n\nimport gevent\nimport time\ndef eat():\n    print('eat food 1')\n    time.sleep(2)\n    print('eat food 2')\n\ndef play():\n    print('play 1')\n    time.sleep(1)\n    print('play 2')\n\ng1=gevent.spawn(eat)\ng2=gevent.spawn(play_phone)\ngevent.joinall([g1,g2])\nprint('主')\n")])])]),t("p",[e._v("我们可以用threading.current_thread().getName()来查看每个g1和g2，查看的结果为DummyThread-n，即假线程")])])}),[],!1,null,null,null);n.default=i.exports}}]);