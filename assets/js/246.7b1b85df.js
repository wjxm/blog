(window.webpackJsonp=window.webpackJsonp||[]).push([[246],{667:function(e,n,t){"use strict";t.r(n);var a=t(30),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("同步锁")]),e._v(" "),t("p",[e._v("线程死锁和递归锁")]),e._v(" "),t("p",[e._v("信号量")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import threading,time\nclass myThread(threading.Thread):\n    def run(self):\n        if semaphore.acquire():\n            print(self.name)\n            time.sleep(5)\n            semaphore.release()\nif __name__=="__main__":\n    semaphore=threading.Semaphore(5)\n    thrs=[]\n    for i in range(100):\n        thrs.append(myThread())\n    for t in thrs:\n        t.start()\n')])])]),t("p",[e._v("条件变量同步")]),e._v(" "),t("p",[e._v("线程之间的 交互")]),e._v(" "),t("p",[e._v("lock.wait()会陷入等待状态，通过notify（）取消，此时从lock.wait()之前的那把锁开始执行")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import threading,time\nfrom random import randint\nclass Producer(threading.Thread):\n    def run(self):\n        global L\n        while True:\n            val=randint(0,100)\n            print(\'生产者\',self.name,":Append"+str(val),L)\n            if lock_con.acquire():\n                L.append(val)\n                lock_con.notify()\n                lock_con.release()\n            time.sleep(3)\nclass Consumer(threading.Thread):\n    def run(self):\n        global L\n        while True:\n                lock_con.acquire()\n                if len(L)==0:\n                    lock_con.wait()\n                print(\'消费者\',self.name,":Delete"+str(L[0]),L)\n                del L[0]\n                lock_con.release()\n                time.sleep(0.25)\n\nif __name__=="__main__":\n\n    L=[]\n    lock_con=threading.Condition()\n    threads=[]\n    for i in range(5):\n        threads.append(Producer())\n    threads.append(Consumer())\n    for t in threads:\n        t.start()\n    for t in threads:\n        t.join()\n')])])]),t("p",[e._v("同步条件 (Event)")]),e._v(" "),t("p",[e._v("条件同步和条件变量同步差不多意思，只是少了锁功能，因为条件同步设计于不访问共享资源的条件环境。event=threading.Event()：条件环境对象，初始值 为False；")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("event.isSet()：返回event的状态值；\nevent.wait()：如果 event.isSet()==False将阻塞线程；\nevent.set()： 设置event的状态值为True，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；\nevent.clear()：恢复event的状态值为False。队列queue\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<strong>创建一个队列对象\n</strong>import Queue\nq = Queue.Queue(maxsize = 10)\nQueue.Queue类即是一个队列的同步实现。队列长度可为无限或者有限。可通过Queue的构造函数的可选参数maxsize来设定队列长度。如果maxsize小于1就表示队列长度无限。\n多放或多取都会堵塞\n<strong>将一个值放入队列中\nq.put(</strong>**10****)**\n调用队列对象的put()方法在队尾插入一个项目。put()有两个参数，第一个item为必需的，为插入项目的值；第二个block为可选参数，默认为\n1。如果队列当前为空且block为1，put()方法就使调用线程暂停,直到空出一个数据单元。如果block为0，put方法将引发Full异常。\n\n<strong>将一个值从队列中取出\nq.get(0）</strong>\n调用队列对象的get()方法从队头删除并返回一个项目。可选参数为block，默认为True。如果队列为空且block为True，get()就使调用线程暂停，直至有项目可用。如果队列为空且block为False，队列将引发Empty异常。\n\n<strong>Python Queue模块有三种队列及构造函数:\n</strong>1、Python Queue模块的FIFO队列先进先出。  class queue.Queue(maxsize)\n2、LIFO类似于堆，即先进后出。             class queue.LifoQueue(maxsize)\n3、还有一种是优先级队列级别越低越先出来。   class queue.PriorityQueue(maxsize)\n\n**此包中的常用方法(q ****=**** Queue.Queue()):**\nq.qsize() 返回队列的大小\nq.empty() 如果队列为空，返回True,反之False\nq.full() 如果队列满了，返回True,反之False\nq.full 与 maxsize 大小对应\nq.get([block[, timeout]]) 获取队列，timeout等待时间\nq.get_nowait() 相当q.get(False)\n非阻塞 q.put(item) 写入队列，timeout等待时间\nq.put_nowait(item) 相当q.put(item, False)\nq.task_done() 在完成一项工作之后，q.task_done() 函数向任务已经完成的队列发送一个信号\nq.join() 实际上意味着等到队列为空，再执行别的操作\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);