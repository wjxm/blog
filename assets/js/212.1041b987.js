(window.webpackJsonp=window.webpackJsonp||[]).push([[212],{633:function(_,e,v){"use strict";v.r(e);var t=v(30),n=Object(t.a)({},(function(){var _=this,e=_.$createElement,v=_._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("本节导读：")]),_._v(" "),v("ul",[v("li",[_._v("可迭代对象")]),_._v(" "),v("li",[_._v("迭代器")]),_._v(" "),v("li",[_._v("可迭代和迭代器的区别")]),_._v(" "),v("li",[_._v("判断迭代器和可迭代对象的方法")]),_._v(" "),v("li",[_._v("生成器")])]),_._v(" "),v("p",[_._v("一 可迭代对象")]),_._v(" "),v("p",[_._v("什么叫迭代？：一个一个取值，就像for循环一样取值")]),_._v(" "),v("p",[_._v("可以直接作用于"),v("code",[_._v("for")]),_._v("循环的对象统称为可迭代对象："),v("code",[_._v("Iterable，有以下两类")])]),_._v(" "),v("ul",[v("li",[_._v("一类是集合数据类型，如"),v("code",[_._v("list")]),_._v("、"),v("code",[_._v("tuple")]),_._v("、"),v("code",[_._v("dict")]),_._v("、"),v("code",[_._v("set")]),_._v("、"),v("code",[_._v("str")]),_._v("等；")]),_._v(" "),v("li",[_._v("一类是"),v("code",[_._v("generator")]),_._v("，包括生成器和带"),v("code",[_._v("yield")]),_._v("的generator function。")])]),_._v(" "),v("p",[_._v("迭代器协议：可以被迭代要满足要求的就叫做可迭代协议。内部实现了__iter__方法")]),_._v(" "),v("p",[_._v("二 迭代器")]),_._v(" "),v("p",[_._v("可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator，其内部实现了__iter__，__next__方法，")]),_._v(" "),v("p",[_._v("迭代器大部分都是在python的内部去使用的，我们直接拿来用就行了")]),_._v(" "),v("p",[_._v("迭代器的优点：如果用了迭代器，节约内存，方便操作")]),_._v(" "),v("p",[_._v("三 可迭代和迭代器的相同点和不同点")]),_._v(" "),v("p",[_._v("都可以用for循环，迭代器内部多实现了一个__next__方法")]),_._v(" "),v("p",[_._v("四判断迭代器和可迭代对象的方法")]),_._v(" "),v("p",[_._v("第一种：判断内部是不是实现了__next__方法")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v(" '__iter__' in dir(str)#如果__iter__在这个方法里面，就是可迭代的。\n")])])]),v("p",[_._v("第二种：")]),_._v(" "),v("p",[_._v("Iterable 判断是不是可迭代对象")]),_._v(" "),v("p",[_._v("Iterator 判断是不是迭代器")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("from collections import Iterable  \nfrom collections import Iterator\n\n#比如给一个字符串\ns='abc'\nprint(isinstance(s,Iterable))#isinstance判断类型的\nprint(isinstance(s,Iterator))\n\n#判断range和map函数\nmap1=map(abs,[1,-2,3,-4])\nprint(isinstance(map1,Iterable))\nprint(isinstance(map1,Iterator))#map方法自带迭代器\n\ns=range(100)#是一个可迭代的，但是不是迭代器\nprint(isinstance(s,Iterable))\nprint(isinstance(s,Iterator))\n")])])]),v("p",[_._v("五 生成器")]),_._v(" "),v("p",[_._v("列表生成式")]),_._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[_._v("# ======一层循环======\nl = [i*i for i in range(1,10)]\nprint(l)\n# 上面的列表推倒式就相当于下面的\nl  = []\nfor i in range(1,10):\n    l.append(i*i)\nprint(l)\nl = []\n\n\n# ======多层循环========\n# 1.列表推倒式\nl = [i*j for i in range(1,10) for j in range(1,10)]\nprint(l)\n# 2.循环\nl = []\nfor i in range(1,10):\n    for j in range(1,10):\n        s = i*j\n        l.append(s)\nprint(l)\n")])])]),v("p",[_._v("通过列表生成式，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。")]),_._v(" "),v("p",[_._v("生成器不必创建完整的list，通过next()方法随用随取，从而节省大量的空间。")]),_._v(" "),v("p",[v("strong",[_._v("生成器的创建")])]),_._v(" "),v("ul",[v("li",[_._v("生成器表达式只要把一个列表生成式的"),v("code",[_._v("[]")]),_._v("改成"),v("code",[_._v("()，")])]),_._v(" "),v("li",[_._v("yield生成器函数,遇到yeild，函数就冻结，并返回yeild后面的值，同过next()方法，使函数继续从yeild之后执行如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用次方法来实现。")])]),_._v(" "),v("p",[_._v("yield函数：")]),_._v(" "),v("li",[_._v("send 用法\n"),v("pre",[_._v("def test():\n    for i in range(10):\n         ret = yield\n         print('这是send发送的结果',ret)\n\na = test()\nnext(a)  # 在send数据前必须要先next一下，不然会报错\na.send('asdf')")])]),_._v(" "),v("li",[_._v("yield from 用法\n"),v("pre",[_._v("def func():\n    # for i in 'AB':\n    #     yield i\n    yield from 'AB'     yield from 'AB'就相当于上面的for循环，吧循环简化了\n    yield from [1,2,3]\n\ng=func()\nprint(list(g))\n# print(next(g))\n# print(next(g))\n\n")])]),_._v(" "),v("p",[_._v("你可能会问，为什么"),v("code",[_._v("list")]),_._v("、"),v("code",[_._v("dict")]),_._v("、"),v("code",[_._v("str")]),_._v("等数据类型不是"),v("code",[_._v("Iterator")]),_._v("？")]),_._v(" "),v("p",[_._v("这是因为Python的"),v("code",[_._v("Iterator")]),_._v("对象表示的是一个数据流，Iterator对象可以被"),v("code",[_._v("next()")]),_._v("函数调用并不断返回下一个数据，直到没有数据时抛出"),v("code",[_._v("StopIteration")]),_._v("错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过"),v("code",[_._v("next()")]),_._v("函数实现按需计算下一个数据，所以"),v("code",[_._v("Iterator")]),_._v("的计算是惰性的，只有在需要返回下一个数据时它才会计算。")]),_._v(" "),v("p",[v("code",[_._v("Iterator")]),_._v("甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。")]),_._v(" "),v("p",[v("strong",[_._v("小结")])]),_._v(" "),v("p",[v("strong",[_._v("生成器都是"),v("code",[_._v("Iterator")]),_._v("对象，但"),v("code",[_._v("list")]),_._v("、"),v("code",[_._v("dict")]),_._v("、"),v("code",[_._v("str")]),_._v("虽然是"),v("code",[_._v("Iterable")]),_._v("，却不是"),v("code",[_._v("Iterator")]),_._v("。")])]),_._v(" "),v("p",[_._v("凡是可作用于"),v("code",[_._v("for")]),_._v("循环的对象都是"),v("code",[_._v("Iterable")]),_._v("类型；")]),_._v(" "),v("p",[_._v("凡是可作用于"),v("code",[_._v("next()")]),_._v("函数的对象都是"),v("code",[_._v("Iterator")]),_._v("类型，它们表示一个惰性计算的序列；")]),_._v(" "),v("p",[_._v("集合数据类型如"),v("code",[_._v("list")]),_._v("、"),v("code",[_._v("dict")]),_._v("、"),v("code",[_._v("str")]),_._v("等是"),v("code",[_._v("Iterable")]),_._v("但不是"),v("code",[_._v("Iterator")]),_._v("，不过可以通过"),v("code",[_._v("iter()")]),_._v("函数获得一个"),v("code",[_._v("Iterator")]),_._v("对象。")])])}),[],!1,null,null,null);e.default=n.exports}}]);