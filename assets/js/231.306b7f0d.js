(window.webpackJsonp=window.webpackJsonp||[]).push([[231],{652:function(e,t,n){"use strict";n.r(t);var s=n(30),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("p",[e._v("本节导读：")]),e._v(" "),n("ul",[n("li",[e._v("什么是socket")]),e._v(" "),n("li",[e._v("socket通信讨论")]),e._v(" "),n("li",[e._v("socket套接字方法")]),e._v(" "),n("li",[e._v("socket服务端客户端的创建")])]),e._v(" "),n("p",[e._v("一 什么是scoket")]),e._v(" "),n("img",{attrs:{src:"https://www.luffycity.com/python-book/assets/6.2socket.png",alt:""}}),e._v(" "),n("p",[e._v("你想给另一台计算机发消息，你知道他的IP地址，他的机器上同时运行着qq、迅雷、word、浏览器等程序，你想给他的qq发消息，那想一下，你现在只能通过ip找到他的机器，但如果让这台机器知道把消息发给qq程序呢？答案就是通过port,一个机器上可以有0-65535个端口，你的程序想从网络上收发数据，就必须绑定一个端口，这样，远程发到这个端口上的数据，就全会转给这个程序")]),e._v(" "),n("p",[e._v("二 socket的工作流程")]),e._v(" "),n("p",[e._v("下面我们举个打电话的小例子来说明一下")]),e._v(" "),n("p",[e._v("如果你要给你的一个朋友打电话，先拨号，朋友听到电话铃声后提起电话，这时你和你的朋友就建立起了连接，就可以讲话了。等交流结束，挂断电话结束此次交谈。 生活中的场景就解释了这工作原理。")]),e._v(" "),n("p",[e._v("（如果你去一家餐馆吃饭，假设哪里的老板就是服务端，而你自己就是客户端，当你去吃饭的时候，你肯定的知道那个餐馆，也就是服务端的地址吧，但是对于你自己来说，餐馆的老板不需要知道你的地址吧）")]),e._v(" "),n("img",{attrs:{src:"https://images2017.cnblogs.com/blog/1184802/201708/1184802-20170821161526777-1550555645.png",alt:""}}),e._v(" "),n("p",[e._v("三 socket套接字方法")]),e._v(" "),n("p",[n("strong",[e._v("socket参数")])]),e._v(" "),n("p",[n("strong",[e._v("family(socket家族)")])]),e._v(" "),n("ul",[n("li",[e._v("socket.AF_UNIX：用于本机进程间通讯，为了保证程序安全，两个独立的程序(进程)间是不能互相访问彼此的内存的，但为了实现进程间的通讯，可以通过创建一个本地的socket来完成")]),e._v(" "),n("li",[e._v("socket.AF_INET:(还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET)")])]),e._v(" "),n("p",[n("strong",[e._v("socket type类型")])]),e._v(" "),n("ul",[n("li",[e._v("socket.SOCK_STREAM #for tcp")]),e._v(" "),n("li",[e._v("socket.SOCK_DGRAM #for udp")]),e._v(" "),n("li",[e._v("socket.SOCK_RAW #原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。")]),e._v(" "),n("li",[e._v("socket.SOCK_RDM #是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议的低级访问，在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用。")]),e._v(" "),n("li",[e._v("socket.SOCK_SEQPACKET #废弃了")])]),e._v(" "),n("blockquote"),e._v(" "),n("p",[e._v("(Only SOCK_STREAM and SOCK_DGRAM appear to be generally useful.)")]),e._v(" "),n("p",[e._v("fileno=None 请忽略，特殊用途")]),e._v(" "),n("p",[n("strong",[e._v("socket函数")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("phone.bind('主机ip地址',端口号)  #绑定到（主机，端口号）套接字\nphone.listen() #开始TCP监听\nphone.accept() #被动接受TCP客户的连接，等待连接的到来\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("s.connect()  #主动初始化TCP服务器连接\ns.connect_ex()   #connect()函数的扩展版本,出错时返回出错码,而不是抛出异常\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("s.recv()  #接收数据\ns.send()# 发送数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完，可后面通过实例解释)\ns.sendall()  #发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)\ns.recvfrom()  #Receive data from the socket. The return value is a pair (bytes, address)\ns.getpeername()  #连接到当前套接字的远端的地址\ns.sendto() #发送UDP数据\ns.getsockname() #返回指定套接字的参数\ns.setsockopt() #设置指定套接字的参数\ns.close()  # 关闭套接字\nsocket.setblocking(flag) #True or False,设置socket为非阻塞模式，以后讲io异步时会用\nsocket.getaddrinfo(host, port, family=0, type=0, proto=0, flags=0)   #返回远程主机的地址信息，例子 socket.getaddrinfo('luffycity.com',80)\nsocket.getfqdn()# 拿到本机的主机名\nsocket.gethostbyname()  # 通过域名解析ip地址\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("phone.setblocking()  #设置套接字的阻塞与非阻塞模式\nphone.settimeout()  #设置阻塞套接字操作的超时时间\nphone.gettimeout()  #得到阻塞套接字操作的超时时间\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("phone.fileno()  # 套接字的文件描述符\nphone.makefile() #创建一个与该套接字相关的文件\n")])])]),n("p",[e._v("四 socket 服务端，客户端的创建")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import socket\nphone = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#买手机\nphone.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,1) #可以多次启动\n#执行多次的时候会报错，那么怎么办呢、？就在绑卡前面加上上面那句setsockopt方法就ok了\nphone.bind(('192.168.20.44',8080))#绑定手机卡(ip,端口)\n# 端口号在1024以前的是系统用的，1024以后的都是你自己写的程序去定义的端口\n\nprint('starting run......')\nphone.listen(5) #开机   5代表的是最多挂起5个，也可以好多个\nwhile True: #链接循环\n    coon,client_addr=phone.accept()#等待接电话,（coon是建立的链接，客户端的ip和端口号组成的元组）\n    print(coon,client_addr)\n\n    #收发消息\n    while True:  #通信循环\n        try:  #如果不加try...except ,就会报错，因为它不知道你什么时候断开链接的，服务器还以为你在运行\n            data = coon.recv(1024) #收了1024个字节的消息\n            print('client data 收到消息:%s'%data.decode('utf-8'))\n            coon.send(data.upper())  #发消息\n        except Exception:  #因为你不知道客户端什么时候断开链接，\n            break\n    coon.close() #挂电话\nphone.close() #关机\n\n\n# 处理逻辑错误的两种方式：\n    # if 判断\n    # try...except 异常处理\n# 异常处理\n# 当你知道直接错误的条件时就用if判断了\n# 当程序错误一定发生，但是你又预知不了它出错的条件是什么的时候，就用try...except\n\n服务端\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import socket\nphone = socket.socket(socket.AF_INET,socket.SOCK_STREAM)#买手机\nphone.connect(('192.168.20.44',8080))  #直接连接服务端的ip和端口\n\n# 发收消息\nwhile True:\n    msg = input('>>:').strip()  #用户输入\n    if not msg:continue  #如果为空就继续输\n    phone.send(msg.encode('utf-8'))  #  发送你输入的消息\n    # phone.send('hello'.encode('utf-8'))\n    data = phone.recv(1024)  #在接收一下\n    print('server back res服务端返回结果:>>%s'%data.decode('utf-8'))\n\nphone.close()\n")])])]),n("p",[n("strong",[e._v("注意：")])]),e._v(" "),n("p",[e._v("如果你在重启服务端的时候可能遇到这样的问题：")]),e._v(" "),n("img",{attrs:{src:"https://images2017.cnblogs.com/blog/1184802/201708/1184802-20170821170908121-1524533925.png",alt:""}}),e._v(" "),n("p",[e._v("这个是由于你的服务端仍然存在四次挥手的time_wait状态在占用地址（如果不懂，请深入研究1.tcp三次握手，四次挥手 2.syn洪水攻击 3.服务器高并发情况下会有大量的time_wait状态的优化方法）。那么怎么解决呢？你也可以这样的")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1 #加入一条socket配置，重用ip和端口\n2 \n3 phone=socket(AF_INET,SOCK_STREAM)\n4 phone.setsockopt(SOL_SOCKET,SO_REUSEADDR,1) #就是它，在bind前加\n5 phone.bind(('127.0.0.1',8080))\n")])])]),n("p",[e._v("基于tcp协议模拟ssh远程执行命令")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("import socket\nimport subprocess\nphone=socket.socket(socket.AF_INET,socket.SOCK_STREAM)#买手机\nphone.bind(('192.168.20.44',8081))#绑定手机卡\nphone.listen(5)#阻塞的最大个数\nprint('starting....')\nwhile True:\n    conn,addr=phone.accept()#等待连接\n    print(addr,conn)\n    while True:\n        cmd=conn.recv(10240)#接收的最大值\n        # if not cmd :break\n        print('接收的是：%s'%cmd.decode('utf-8'))\n        #处理过程\n        res=subprocess.Popen(cmd.decode('utf-8'),shell=True,   #Popen是执行命令的方法\n                             stdout=subprocess.PIPE,\n                             stderr=subprocess.PIPE )\n        stdout=res.stdout.read()\n        stuerr=res.stderr.read()\n        conn.send(stdout+stuerr)\n    conn.close()\nphone.close()\n")])])]),n("p",[e._v("基于udp协议的socket")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("from socket import *\nudp_server = socket(AF_INET,SOCK_DGRAM)\nudp_server.bind(('127.0.0.1',8080)) #绑定\nwhile True:#通讯循环\n    msg,client_addr= udp_server.recvfrom(1024)\n    print('收到的消息是：%s'%msg.decode('utf-8'))\n    udp_server.sendto(msg.upper(),client_addr)\nudp_server.close()\n")])])])])}),[],!1,null,null,null);t.default=o.exports}}]);