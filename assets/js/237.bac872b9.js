(window.webpackJsonp=window.webpackJsonp||[]).push([[237],{657:function(e,_,o){"use strict";o.r(_);var t=o(30),s=Object(t.a)({},(function(){var e=this,_=e.$createElement,o=e._self._c||_;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[o("strong",[e._v("反射")]),e._v('用户输入什么属性，直接调用该属性通过字符串，映射到属性上通过一个字符串来映射到（访问）对象的属性，叫做反射choice = input(">>")print(obj.choice)')]),e._v(" "),o("p",[e._v("hasattr(obj,\"name\") #判断obj下有没有name属性getattr（obj,'name',None) #拿到obj对象的name属性，没有返回Nonesetattr(obj,'name','alex') 本质上是obj.name ='alex' 赋值delattr(obj,\"age') #del obj.age")]),e._v(" "),o("p",[o("strong",[e._v("内置方法")]),e._v("iterm系列将对象模拟成字典去操作它的属性")]),e._v(" "),o("p",[e._v("元类exec（）相当于一个函数去执行，里面的变量是局部变量")]),e._v(" "),o("p",[e._v("#一切皆对象，对象可以这么用1，都可以被引用，x=obj2,都可以当做函数的参数传入3,都可以当做函数的返回值4,都可以当做容器类的元素但凡有了这四个用法，就是对象类也是对象，产生类的类，就是元类，默认所有用class定义的类，他们的元类都是type定义类的两种方式1，class2，typeexec(class_body,globel(),class_dic)Chinese = type(class_name,class_base,clsee_dic) #类的名字，类的基类，类的名称空间")]),e._v(" "),o("p",[e._v("自定义元类控制类的创建继承type，重写__init__()")]),e._v(" "),o("p",[e._v("内置方法")]),e._v(" "),o("p",[e._v("元类")]),e._v(" "),o("p",[e._v("#__call__方法使对象可调用class Foo:def "),o("strong",[e._v("call")]),e._v("(self,*args,**kwargs)造出空对象obj= object."),o("strong",[e._v("new")]),e._v("(self）初始化objself."),o("strong",[e._v("init")]),e._v("(obj,*args,**kwargs) 返回obj return obj")]),e._v(" "),o("p",[e._v("obj = Foo()实例化对象有三步造出空对象初始化obj返回obj obj(1,2,3,a =1)元类内部也应该有一个__call__方法，会在调用Foo时触发执行")]),e._v(" "),o("p",[e._v("自定义元类控制类的实例化行为的应用单例模式实现多次实例化，得到的对象都是一样")]),e._v(" "),o("p",[e._v("面向对象软件开发1抽象化类，理清类与类之间的关系")]),e._v(" "),o("p",[e._v("现实中没有逻辑这个类定义一些现实中本来不存在的类通常属性是名词方法是动词")])])}),[],!1,null,null,null);_.default=s.exports}}]);