(window.webpackJsonp=window.webpackJsonp||[]).push([[222],{642:function(n,t,e){"use strict";e.r(t);var r=e(30),a=Object(r.a)({},(function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("** 常用的re语法**")]),n._v(" "),e("p",[n._v("re.match 从头开始匹配      ,用$最好不用match")]),n._v(" "),e("p",[n._v("re.search 匹配包含，匹配到一个就结束    判断有没有返回结果，有结果可以通过group()返回结果，否则就会报错")]),n._v(" "),e("ul",[e("li",[n._v("group()    返回search,match结果")]),n._v(" "),e("li",[n._v("groups()，分组匹配时分开结果")])]),n._v(" "),e("p",[n._v("re.findall 把所有匹配到的字符放到以列表中的元素返回")]),n._v(" "),e("p",[n._v("re.split 以匹配到的字符当做列表分隔符")]),n._v(" "),e("p",[n._v("re.sub 匹配字符并替换")]),n._v(" "),e("p",[n._v("re.fullmatch 全部匹配")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('<code> **表示字符**\n.\t匹配任意1个字符（除了\\n）\n[ ]\t匹配[ ]中列举的字符\\d\t匹配数字，即0-9\n\\D\t匹配非数字，即不是数字\n\\s\t匹配空白，即 空格，tab键\\t、\\n、\\r \n\\S\t匹配非空白\n\\w\t匹配单词字符，即a-z、A-Z、0-9、_\n\\W\t匹配非单词字符\n\n**表示数量**\n*\t匹配前一个字符出现0次或者无限次，即可有可无\n+\t匹配前一个字符出现1次或者无限次，即至少有1次\n?\t匹配前一个字符出现1次或者0次，即要么有1次，要么没有\n{m}\t匹配前一个字符出现m次\n{m,}\t匹配前一个字符至少出现m次\n{m,n}\t匹配前一个字符出现从m到n次\n\n**表示边界**\n^\t匹配字符串开头\n$\t匹配字符串结尾\\A      只从字符开头匹配\\Z      匹配字符结尾\n\\b\t匹配一个单词的边界    配合r""使用\n\\B\t匹配非单词边界\n**匹配分组**\n|\t匹配左右任意一个表达式\n(ab)\t将括号中字符作为一个分组\n\\num\t引用分组num匹配到的字符串\n(?P<name>)\t分组起别名\n(?P=name)\t引用别名为name分组匹配到的字符串\n**贪婪匹配**\nPython里数量词默认是贪婪的，总是尝试匹配尽可能多的字符\n在"*","?","+","{m,n}"后面加上？，使贪婪变成非贪婪。标志符re.I(re.IGNORECASE): 忽略大小写（括号内是完整写法，下同）re.M(MULTILINE): 多行模式,，改变\'^\'和\'$\'的行为 遇到换行符，就认为是结尾re.S(DOTALL): 改变\'.\'的行为，本来不匹配换行符，加入此标志符，连换行符也要匹配re.X(re.VERBOSE) 可以给你的表达式写注释，使其更可读，下面这2个意思一样\n</code>\n')])])]),e("p",[e("code")])])}),[],!1,null,null,null);t.default=a.exports}}]);