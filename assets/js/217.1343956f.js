(window.webpackJsonp=window.webpackJsonp||[]).push([[217],{638:function(e,a,s){"use strict";s.r(a);var t=s(30),n=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("p",[e._v("注：本节内容来源于python+cookbook")]),e._v(" "),s("p",[e._v("查找最大或最小的 N 个元素")]),e._v(" "),s("p",[e._v("heapq 模块有两个函数： nlargest() 和 nsmallest() 可以完美解决这个问题。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import heapq\nnums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]\nprint(heapq.nlargest(3, nums)) # Prints [42, 37, 23]\nprint(heapq.nsmallest(3, nums)) # Prints [-4, 1, 2]\n")])])]),s("p",[e._v("两个函数都能接受一个关键字参数，用于更复杂的数据结构中：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("portfolio = [\n{'name': 'IBM', 'shares': 100, 'price': 91.1},\n{'name': 'AAPL', 'shares': 50, 'price': 543.22},\n{'name': 'FB', 'shares': 200, 'price': 21.09},\n{'name': 'HPQ', 'shares': 35, 'price': 31.75},\n{'name': 'YHOO', 'shares': 45, 'price': 16.35},\n{'name': 'ACME', 'shares': 75, 'price': 115.65}\n]\ncheap = heapq.nsmallest(3, portfolio, key=lambda s: s['price'])\nexpensive = heapq.nlargest(3, portfolio, key=lambda s: s['price'])\n")])])]),s("p",[e._v("上面代码在对每个元素进行对比的时候，会以 price 的值进行比较。")]),e._v(" "),s("p",[e._v("当要查找的元素个数相对比较小的时候，函数 nlargest() 和 nsmallest() 是很合适的。如果你仅仅想查找唯一的最小或最大（ N=1）的元素的话，那么使用 min() 和max() 函数会更快些。类似的，如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点（ sorted(items)[:N] 或者是 sorted(items)[-N:]）。需要在正确场合使用函数 nlargest() 和 nsmallest() 才能发挥它们的优势（如果N 快接近集合大小了，那么使用排序操作会更好些）")]),e._v(" "),s("p",[e._v("注：经测试1万个数以内，两种方法的误差可以不计，1万以上heapq的效率是shorted的几倍")]),e._v(" "),s("p",[e._v("heapq其他方法")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("heapq.heapify(nums)   #排序\nheapq.heapqpop #取出当前最小元素\n")])])]),s("p",[e._v("1.5 实现一个优先级队列问题怎样实现一个按优先级排序的队列？并且在这个队列上面每次 pop 操作总是返回优先级最高的那个元素解决方案下面的类利用 heapq 模块实现了一个简单的优先级队列：")]),e._v(" "),s("blockquote",[s("blockquote",[s("blockquote",[s("p",[e._v("仔细观察可以发现，第一个 pop() 操作返回优先级最高的元素。另外注意到如果两个有着相同优先级的元素（ foo 和 grok ）， pop 操作按照它们被插入到队列的顺序返回的。")])])])])])}),[],!1,null,null,null);a.default=n.exports}}]);