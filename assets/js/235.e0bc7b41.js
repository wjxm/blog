(window.webpackJsonp=window.webpackJsonp||[]).push([[235],{655:function(t,a,e){"use strict";e.r(a);var r=e(30),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"继承-inherit"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承-inherit"}},[t._v("#")]),t._v(" 继承(Inherit)")]),t._v(" "),e("h3",{attrs:{id:"继承的概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#继承的概念"}},[t._v("#")]),t._v(" 继承的概念")]),t._v(" "),e("ul",[e("li",[t._v("子类继承父类的内容，包括字段、方法、属性。")]),t._v(" "),e("li",[t._v("将多个类共有的方法提取到父类中，子类仅需继承父类而不必一一实现每个方法。")]),t._v(" "),e("li",[t._v("基类和派生类只是与父类、子类的叫法不一样")])]),t._v(" "),e("p",[e("strong",[t._v("查看继承")])]),t._v(" "),e("p",[t._v("class."),e("strong",[t._v("bases")]),t._v("#__base__只查看从左到右继承的第一个子类，__bases__则是查看所有继承的父类")]),t._v(" "),e("p",[e("strong",[t._v("继承的查找顺序")])]),t._v(" "),e("p",[t._v("先在自己对象里找，然后去类里找，最后去父类里去找")]),t._v(" "),e("p",[t._v("哪一个对象调用，self就是代指的哪一个对象，(父类，子类里的self，都是对象)")]),t._v(" "),e("h4",{attrs:{id:"多继承"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#多继承"}},[t._v("#")]),t._v(" 多继承")]),t._v(" "),e("ol",[e("li",[t._v("Java和C#中则只能继承一个类，Python的类可以继承多个类")]),t._v(" "),e("li",[t._v("Python的类如果继承了多个类，那么其寻找方法的方式有两种，分别是：深度优先和广度优先")])]),t._v(" "),e("li",[t._v("python2中分经典类和新式类，经典类为深度优先，新式类为广度优先。\n"),e("ul",[t._v("\n- 经典类：自定义最开始的类不继承任何东西\n- 新式类：自定义最开始的类继承object类\n"),e("ul",[e("li",[e("p",[t._v("示例")])]),t._v(" "),e("li",[e("p",[t._v("示例")])])]),t._v(" "),e("h3",{attrs:{id:""}},[e("a",{staticClass:"header-anchor",attrs:{href:"#"}},[t._v("#")])]),t._v(" "),e("p",[e("strong",[t._v("在子类中重用父类的属性")]),e("br",{attrs:{"data-filtered":"filtered"}}),t._v("方式一"),e("br",{attrs:{"data-filtered":"filtered"}}),t._v("指名道姓： (不依赖继承)"),e("br",{attrs:{"data-filtered":"filtered"}}),t._v("新方法下执行")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("def new():\n    父类.方法（）\n    父类.__init__() #调用父类的init方法\n")])])]),e("p",[t._v("方式二"),e("br",{attrs:{"data-filtered":"filtered"}}),t._v("super() (依赖继承)"),e("br",{attrs:{"data-filtered":"filtered"}}),t._v("super(自己类名，self).方法() 得到一个父类的对象"),e("br",{attrs:{"data-filtered":"filtered"}}),t._v("super(自己类名，self)."),e("strong",[t._v("init")]),t._v("()"),e("br",{attrs:{"data-filtered":"filtered"}}),t._v("python3简写为super().方法()"),e("br",{attrs:{"data-filtered":"filtered"}}),t._v("super()从mro列表当前位置往后去找，")]),t._v(" "),e("h3",{attrs:{id:"抽象类和接口类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#抽象类和接口类"}},[t._v("#")]),t._v(" 抽象类和接口类")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("<code>from abc import ABCmeta, abstractmethod\nclass Person(classmeta=ABCmeta)\n</code>\n")])])]),e("li",[t._v("抽象类：\n"),e("ul",[t._v("\n- 在Python中，默认是有的\n- 父类的方法子类必须实现\n- 抽象类不能被实例化\n- 抽象类内的方法可以被简单实现\n- 抽象类不建议多继承\n"),e("ul",[e("li",[t._v("做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象")]),t._v(" "),e("li",[t._v("在python中，默认是没有的，只是一种程序设计理念")]),t._v(" "),e("li",[t._v("接口类的方法不能被实现\n")]),e("li",[t._v("接口隔离原则：\n"),e("ul")]),t._v(" "),e("li",[t._v("应该有多个独立的接口，而不是多功能的单个接口")])])])])])])])}),[],!1,null,null,null);a.default=s.exports}}]);